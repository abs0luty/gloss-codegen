import config.{type Config, type TypeConfig}
import glance
import gleam/dict
import gleam/int
import gleam/io
import gleam/list
import gleam/option.{None, Some}
import gleam/result
import gleam/string
import gleam_parser
import simplifile
import string_utils

pub type GeneratedFile {
  GeneratedFile(path: String, content: String)
}

pub fn generate_for_directory(
  dir: String,
  config: Config,
) -> Result(List(GeneratedFile), String) {
  use files <- result.try(
    simplifile.read_directory(dir)
    |> result.map_error(fn(_) { "Failed to read directory: " <> dir }),
  )

  let gleam_files =
    files
    |> list.filter(fn(f) { string.ends_with(f, ".gleam") })
    |> list.map(fn(f) { dir <> "/" <> f })

  gleam_files
  |> list.map(fn(file) { generate_for_file(file, config) })
  |> result.all
  |> result.map(list.flatten)
}

/// Generate encoder and decoder code for a single Gleam file
pub fn generate_for_file(
  path: String,
  config: Config,
) -> Result(List(GeneratedFile), String) {
  use module <- result.try(gleam_parser.parse_gleam_source_file(path))

  let module_name = extract_module_name(path)

  let _ = io.println("  Module: " <> module_name)
  let _ =
    io.println(
      "  Custom types found: "
      <> list.length(module.custom_types) |> int.to_string,
    )
  let type_names =
    module.custom_types
    |> list.map(fn(t) { t.definition.name })
    |> string.join(", ")
  let _ = io.println("  Type names: " <> type_names)

  // Get module-specific config if it exists
  let module_config = dict.get(config.modules, module_name)

  let generated_files =
    module.custom_types
    |> list.filter_map(fn(custom_type) {
      generate_for_type(custom_type, module_name, module_config, config)
    })

  Ok(generated_files)
}

fn extract_module_name(path: String) -> String {
  path
  |> string.split("/")
  |> list.last
  |> result.unwrap("")
  |> string.replace(".gleam", "")
}

fn generate_for_type(
  custom_type: glance.Definition(glance.CustomType),
  module_name: String,
  module_config: Result(config.ModuleConfig, Nil),
  global_config: Config,
) -> Result(GeneratedFile, Nil) {
  let type_name = custom_type.definition.name

  // Debug
  let _ = io.println("    Checking type: " <> type_name)

  // Check if we should generate code for this type
  let type_config = case module_config {
    Ok(mc) -> {
      let _ = io.println("      Module config found")
      let type_keys = dict.keys(mc.types) |> string.join(", ")
      let _ = io.println("      Available type keys: " <> type_keys)
      dict.get(mc.types, type_name)
    }
    Error(_) -> {
      let _ = io.println("      No module config for: " <> module_name)
      Error(Nil)
    }
  }

  case type_config {
    Ok(tc) -> {
      let _ = io.println("      Type config found for: " <> type_name)
      case tc.generate_encoder, tc.generate_decoder {
        Some(True), _ | _, Some(True) -> {
          let _ = io.println("      Generating code for: " <> type_name)
          let content = generate_type_code(custom_type, tc, global_config)
          let file_path =
            global_config.output.directory
            <> "/"
            <> module_name
            <> global_config.output.file_suffix
            <> ".gleam"
          Ok(GeneratedFile(path: file_path, content: content))
        }
        _, _ -> {
          let _ =
            io.println("      No encoder/decoder configured for: " <> type_name)
          Error(Nil)
        }
      }
    }
    Error(_) -> {
      let _ = io.println("      No type config for: " <> type_name)
      Error(Nil)
    }
  }
}

fn generate_type_code(
  custom_type: glance.Definition(glance.CustomType),
  type_config: TypeConfig,
  global_config: Config,
) -> String {
  let imports = generate_imports()
  let type_def = custom_type.definition

  let encoder = case type_config.generate_encoder {
    Some(True) -> Some(generate_encoder(type_def, type_config, global_config))
    _ -> None
  }

  let decoder = case type_config.generate_decoder {
    Some(True) -> Some(generate_decoder(type_def, type_config, global_config))
    _ -> None
  }

  let parts =
    [Some(imports), encoder, decoder]
    |> list.filter(option.is_some)
    |> list.map(fn(x) {
      case x {
        Some(s) -> s
        None -> ""
      }
    })

  string.join(parts, "\n\n")
}

fn generate_imports() -> String {
  "// This file was generated by gloss
// Do not modify this file directly.

import gleam/dynamic
import gleam/json
import gleam/option"
}

fn generate_encoder(
  type_def: glance.CustomType,
  _type_config: TypeConfig,
  _global_config: Config,
) -> String {
  let function_name = "encode_" <> string_utils.to_snake_case(type_def.name)

  "pub fn " <> function_name <> "(value: " <> type_def.name <> ") -> json.Json {
  // TODO: Implement encoder
  json.null()
}"
}

fn generate_decoder(
  type_def: glance.CustomType,
  _type_config: TypeConfig,
  _global_config: Config,
) -> String {
  let function_name = "decode_" <> string_utils.to_snake_case(type_def.name)

  "pub fn "
  <> function_name
  <> "() -> dynamic.Decoder("
  <> type_def.name
  <> ") {
  // TODO: Implement decoder
  dynamic.dynamic
}"
}
